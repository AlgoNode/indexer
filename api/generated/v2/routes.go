// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"mz2dfPx/AQAA//9C2VO/0KgBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
