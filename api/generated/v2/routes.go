// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"XDKV2ZkR5mezp5OP/y8AAP//WtIO58yoAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
