// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"kqnMzowwP5s9nXz+/wEAAP//746gYEChAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
