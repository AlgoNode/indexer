// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
