// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
